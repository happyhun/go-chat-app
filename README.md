# Go Real-Time Chat Application

Go와 최신 웹 기술을 활용하여 구축한 고성능 실시간 채팅 애플리케이션입니다. 이 프로젝트는 Go의 동시성 모델을 깊이 있게 활용하고, 운영 환경에서의 안정성과 관찰 가능성을 확보하는 데 중점을 두었습니다.

---

## 주요 기능

- **다중 채팅방**: 여러 개의 독립적인 채팅방을 생성하고 참여할 수 있습니다.
- **하이브리드 실시간 통신**: WebSocket과 SSE를 목적에 맞게 사용하여 효율적인 양방향/단방향 통신을 구현했습니다.
- **라이브 로비**: SSE를 통해 생성된 채팅방 목록과 참여자 수를 모든 로비 사용자에게 실시간으로 브로드캐스트합니다.
- **닉네임 중복 확인**: 서버 단에서 애플리케이션 전체의 닉네임 유일성을 보장합니다.
- **타이핑 인디케이터**: 다른 사용자가 메시지를 입력 중일 때 이를 알려주는 기능을 제공합니다.
- **구조화된 로깅 (Structured Logging)**: `slog`를 사용하여 모든 로그를 JSON 형식으로 기록, 운영 환경에서의 분석 및 모니터링을 용이하게 합니다.
- **동적인 설정 관리**: 환경 변수를 통해 포트, 타임아웃, 로그 레벨 등 주요 설정을 유연하게 변경할 수 있습니다.
- **우아한 종료 (Graceful Shutdown)**: 서버 종료 시 진행 중인 요청을 안전하게 처리하고 연결을 정상적으로 닫습니다.

## 엔드포인트

| HTTP Method | 경로                   | 설명                                                              |
| ----------- | ---------------------- | ----------------------------------------------------------------- |
| `GET`       | `/`                    | 메인 애플리케이션 페이지 (`index.html`)를 제공합니다.             |
| `GET`       | `/static/*`            | 정적 파일 (CSS, JS)을 제공합니다.                                 |
| `GET`       | `/api/config`          | 클라이언트 설정 (메시지 길이 제한 등)을 반환합니다.               |
| `POST`      | `/api/nicknames/check` | 닉네임 사용 가능 여부를 확인합니다.                               |
| `GET`       | `/api/rooms`           | 현재 활성화된 채팅방 목록을 반환합니다.                           |
| `POST`      | `/api/rooms`           | 새로운 채팅방을 생성합니다.                                       |
| `GET`       | `/api/rooms/stream`    | 로비 업데이트를 위한 SSE(Server-Sent Events) 스트림을 시작합니다. |
| `GET`       | `/ws/{roomID}`         | 특정 채팅방의 웹소켓 연결을 처리합니다.                           |

## 기술 스택

- **백엔드**: Go (1.25)
  - **WebSocket**: `gorilla/websocket`
  - **Structured Logging**: `log/slog` (표준 라이브러리)
  - **동시성**: Goroutines & Channels
- **프론트엔드**: Vanilla JavaScript (ESM), HTML5, CSS3

## 프로젝트 구조

본 프로젝트는 유지보수성과 명확한 관심사 분리를 위해 표준 Go 프로젝트 레이아웃을 따릅니다.

```
go-chat-app/
├── internal/               # 비공개 애플리케이션 및 라이브러리 코드
│   ├── chat/               # 핵심 채팅 로직 (Hub, Client, WebSocket 처리)
│   └── server/             # HTTP 서버, 라우팅, 핸들러
├── web/                    # 프론트엔드 정적 파일 및 템플릿
│   ├── static/             # CSS, JS 파일
│   └── templates/          # HTML 템플릿
├── go.mod
├── go.sum
└── main.go                 # 애플리케이션 진입점
```

- **`internal` 디렉토리**: Go 툴체인에 의해 외부 프로젝트에서의 임포트가 금지됩니다. 이를 통해 프로젝트의 내부 구현을 캡슐화하고 API 경계를 명확히 했습니다.
- **`chat` 패키지**: 허브(채팅방), 클라이언트, 웹소켓 통신 프로토콜 등 모든 실시간 채팅 관련 비즈니스 로직을 담당합니다.
- **`server` 패키지**: HTTP 라우팅, 미들웨어, 정적 파일 서빙 등 웹 서버와 관련된 모든 책임을 가집니다.

## 아키텍처 및 주요 설계 결정

### 1. 하이브리드 실시간 통신: WebSocket과 SSE의 역할 분리

각 기능의 요구사항에 맞춰 두 가지 다른 실시간 통신 기술을 사용했습니다.

- **WebSocket**: 메시지를 주고받는 **양방향 통신**이 필수적인 **채팅방**에 사용했습니다. 클라이언트와 서버가 언제든지 메시지를 보낼 수 있어 실시간 대화에 적합합니다.
- **Server-Sent Events (SSE)**: 서버가 클라이언트에게 방 목록, 참여자 수 등 상태를 **일방적으로 전송**하는 **로비**에 사용하여, 더 가볍고 효율적인 단방향 통신을 구현했습니다. WebSocket에 비해 프로토콜 오버헤드가 적고 구현이 간편합니다.

### 2. 동시성 관리: 고루틴과 채널

Go의 동시성 모델을 활용하여 상태를 안전하고 효율적으로 관리합니다.

- **Hub-Client 아키텍처**: 각 채팅방(`Hub`)은 독립적인 고루틴에서 실행되며, 자신만의 클라이언트 목록과 메시지 채널을 가집니다. `Hub`는 자신의 상태를 관리하면서도, 사용자의 입장/퇴장 시 `HubManager`에 알려 로비 정보가 갱신되도록 상호작용합니다.
- **채널 기반 상태 관리**: 클라이언트의 등록, 해제, 메시지 브로드캐스팅 등 모든 상태 변경 작업은 채널을 통해 `Hub`의 메인 고루틴에서 순차적으로 처리됩니다. 이는 복잡한 Mutex 락 관리 대신 채널을 사용하여 상태 변경을 동기화함으로써, 레이스 컨디션을 원천적으로 방지하고 스레드 안전성을 확보하는 Go의 관용적인(idiomatic) 방식입니다.
- **안전한 고루틴 종료**: 클라이언트의 `readPump` 고루틴이 연결 종료를 감지하면, `defer` 문을 통해 리소스 정리(`unregister` 등)를 보장합니다. `Hub`는 `stop` 채널을 통해 모든 클라이언트의 `writePump`를 안전하게 종료시켜, 이미 닫힌 커넥션에 쓰기를 시도하는 `use of closed network connection` 오류를 방지합니다.

### 3. 우아한 종료 (Graceful Shutdown)

서버는 `os.Signal` (SIGINT, SIGTERM)을 감지하여 우아한 종료를 수행합니다. 이는 운영 환경에서 배포 시 서비스 중단을 최소화하는 데 필수적입니다.

1.  **종료 신호 전파**: `shutdownChan`을 닫아 SSE와 같은 장기 실행 핸들러들에게 종료를 알립니다.
2.  **Hubs 종료**: `HubManager`가 모든 활성 `Hub`에 종료 명령을 내립니다. 각 `Hub`는 연결된 클라이언트들을 정리합니다.
3.  **HTTP 서버 종료**: `http.Server.Shutdown`을 호출하여 진행 중인 모든 HTTP 요청이 완료될 때까지 대기합니다. `context.WithTimeout`을 사용하여 무한 대기를 방지합니다.

### 4. 운영 및 관찰 가능성 (Observability)

안정적인 서비스 운영을 위해 로깅 시스템을 체계적으로 구축했습니다.

- **구조화된 로깅**: Go 1.21에 추가된 표준 라이브러리 `log/slog`를 사용하여 모든 로그를 **JSON 형식**으로 기록합니다. 이를 통해 로그를 기계적으로 파싱하고 Datadog, ELK Stack 같은 로그 분석 도구에서 쉽게 필터링 및 검색할 수 있습니다.
- **동적 로그 레벨**: `LOG_LEVEL` 환경 변수(`DEBUG`, `INFO`, `WARN`, `ERROR`)를 통해 실행 시 로그 상세 수준을 동적으로 제어할 수 있습니다. 개발 환경에서는 `DEBUG`로 상세한 정보를, 프로덕션 환경에서는 `INFO`로 핵심 정보만 확인할 수 있습니다.
- **중앙화된 요청 로깅**: HTTP 미들웨어를 구현하여 모든 수신 요청에 대해 `메서드`, `경로`, `상태 코드`, `처리 시간` 등 핵심 정보를 일관되게 기록합니다. 이는 각 핸들러의 코드를 깔끔하게 유지하면서도 전체 API의 성능과 오류를 모니터링하는 데 필수적입니다.

### 5. 보안 고려사항

- **WebSocket Origin 검증**: Cross-Site WebSocket Hijacking (CSWH) 공격을 방지하기 위해 요청의 `Origin` 헤더를 검증합니다. 허용할 Origin 목록은
  `ALLOWED_ORIGINS` 환경 변수를 통해 설정할 수 있습니다.
- **XSS (Cross-Site Scripting) 방지**: 모든 사용자 입력(닉네임, 메시지)은 프론트엔드에서 `textContent`를 통해 렌더링하여, HTML 태그가 아닌 순수 텍스트로 처리되도록 함으로써 XSS 공격을 방지합니다.
- **콘텐츠 보안 정책 (CSP)**: `default-src 'self'`의 CSP 헤더를 적용하여 신뢰할 수 없는 외부 스크립트나 리소스의 로드를 제한합니다.

## 환경 변수 설정

다음 환경 변수를 통해 애플리케이션의 동작을 설정할 수 있습니다.

- **`LOG_LEVEL`**: 로그 레벨을 설정합니다. (`DEBUG`, `INFO`, `WARN`, `ERROR`) (기본값: `INFO`)
- **`PORT`**: 서버가 실행될 포트 번호입니다. (기본값: `8080`)
- **`SHUTDOWN_TIMEOUT`**: 우아한 종료 시 대기 시간입니다. (기본값: `5s`)
- **`MAX_CHAT_MESSAGE_LENGTH`**: 최대 채팅 메시지 길이입니다. (기본값: `1000`)
- **`ALLOWED_ORIGINS`**: WebSocket 연결을 허용할 Origin 목록입니다 (쉼표로 구분). 설정하지 않으면 개발 편의를 위해 모든 Origin을 허용하며, 프로덕션 환경에서는 반드시 설정해야 합니다.
  - **프로덕션 예시:** `ALLOWED_ORIGINS="https://your-domain.com,https://www.your-domain.com"`
  - **ngrok 예시:** `ALLOWED_ORIGINS="https://your-ngrok-subdomain.ngrok.io"`
