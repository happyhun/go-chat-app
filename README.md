# Go 기반 실시간 채팅 애플리케이션

Go와 웹 기술(WebSocket, SSE)을 사용하여 구현한 실시간 다중 채팅방 애플리케이션입니다. 표준적인 프로젝트 구조를 바탕으로, 동시성 처리와 안전한 서버 운영에 중점을 두고 개발했습니다.

---

## 주요 기능

- **다중 채팅방**: 여러 개의 독립적인 채팅방을 생성하고 참여할 수 있습니다.
- **실시간 통신**: WebSocket과 SSE를 통해 메시지와 상태를 즉시 주고받습니다.
- **라이브 로비**: 생성된 채팅방 목록과 참여자 수를 모든 로비 사용자에게 실시간으로 업데이트합니다.
- **닉네임 중복 확인**: 서버 단에서 애플리케이션 전체의 닉네임 유일성을 보장합니다.
- **타이핑 인디케이터**: 다른 사용자가 메시지를 입력 중일 때 이를 알려주는 기능을 제공합니다.
- **우아한 종료 (Graceful Shutdown)**: 서버 종료 시 진행 중인 요청을 안전하게 처리하고 연결을 정상적으로 닫습니다.

## 기술 스택

- **백엔드**: Go
    - **WebSocket**: `gorilla/websocket`
    - **Server-Sent Events (SSE)**
    - **동시성**: Goroutines & Channels
- **프론트엔드**: Vanilla JavaScript (ESM), HTML5, CSS3

## 프로젝트 구조

본 프로젝트는 유지보수성과 명확한 관심사 분리를 위해 표준 Go 프로젝트 레이아웃을 따릅니다.

```
go-chat-app/
├── internal/               # 비공개 애플리케이션 및 라이브러리 코드
│   ├── chat/               # 핵심 채팅 로직 (Hub, Client, WebSocket 처리)
│   └── server/             # HTTP 서버, 라우팅, 핸들러
├── web/                    # 프론트엔드 정적 파일 및 템플릿
│   ├── static/             # CSS, JS 파일
│   └── templates/          # HTML 템플릿
├── go.mod
├── go.sum
└── main.go                 # 애플리케이션 진입점
```

- **`internal` 디렉토리**: Go 툴체인에 의해 외부 프로젝트에서의 임포트가 금지됩니다. 이를 통해 프로젝트의 내부 구현을 캡슐화하고 API 경계를 명확히 했습니다.
- **`chat` 패키지**: 허브(채팅방), 클라이언트, 웹소켓 통신 프로토콜 등 모든 실시간 채팅 관련 비즈니스 로직을 담당합니다.
- **`server` 패키지**: HTTP 라우팅, 미들웨어, 정적 파일 서빙 등 웹 서버와 관련된 모든 책임을 가집니다.

## 핵심 설계 및 구현

### 1. 실시간 통신: WebSocket과 SSE의 역할 분리

각 기능의 요구사항에 맞춰 두 가지 다른 실시간 통신 기술을 사용했습니다.

- **WebSocket**: 메시지를 주고받는 양방향 통신이 필수적인 **채팅방**에 사용했습니다.
- **Server-Sent Events (SSE)**: 서버가 클라이언트에게 방 목록, 참여자 수 등 상태를 일방적으로 전송하는 **로비**에 사용하여, 더 가볍고 효율적인 단방향 통신을 구현했습니다.

### 2. 동시성 관리: 고루틴과 채널

Go의 동시성 모델을 활용하여 상태를 안전하고 효율적으로 관리합니다.

- **Hub-Client 아키텍처**: 각 채팅방(`Hub`)은 독립적인 고루틴에서 실행되며, 자신만의 클라이언트 목록과 메시지 채널을 가집니다. 이를 통해 각 채팅방의 상태가 격리되어 관리됩니다.
- **채널 기반 상태 관리**: 클라이언트의 등록, 해제, 메시지 브로드캐스팅 등 모든 상태 변경 작업은 채널을 통해 `Hub`의 메인 고루틴에서 순차적으로 처리됩니다. 이는 Mutex 락 대신 채널을 사용하여
  상태 변경을 동기화함으로써, 레이스 컨디션을 방지하고 스레드 안전성을 확보하는 방식입니다.
- **안전한 고루틴 종료**: `readPump`가 연결 종료를 감지하면 `quit` 채널을 닫아 `writePump`에 종료 신호를 보냅니다. 이를 통해 `writePump`가 이미 닫힌 커넥션에 쓰기를 시도하는
  `use of closed network connection` 오류를 방지하고 리소스를 정리합니다.

### 3. 우아한 종료 (Graceful Shutdown)

서버는 `os.Signal`을 감지하여 우아한 종료를 수행합니다. 종료 신호 수신 시, 다음 절차를 따릅니다.

1. 모든 활성 `Hub`에 종료 메시지를 보내 클라이언트에게 서버 종료를 알립니다.
2. 모든 `Hub`의 고루틴이 안전하게 종료될 때까지 대기합니다.
3. `context.WithTimeout`을 사용하여 진행 중인 HTTP 요청이 완료될 시간을 준 후 서버를 종료합니다.

### 4. 보안 고려사항

- **WebSocket Origin 검증**: Cross-Site WebSocket Hijacking (CSWH) 공격을 방지하기 위해 요청의 `Origin` 헤더를 검증합니다. 허용할 Origin 목록은
  `ALLOWED_ORIGINS` 환경 변수를 통해 설정할 수 있습니다.
- **XSS (Cross-Site Scripting) 방지**: 모든 사용자 입력(닉네임, 메시지)은 프론트엔드에서 `textContent`를 통해 렌더링하여, HTML 태그가 아닌 순수 텍스트로 처리되도록
  함으로써 XSS 공격을 방지합니다.
- **콘텐츠 보안 정책 (CSP)**: `default-src 'self'`의 CSP 헤더를 적용하여 신뢰할 수 없는 외부 스크립트나 리소스의 로드를 제한합니다.

## 환경 변수 설정

다음 환경 변수를 통해 애플리케이션의 동작을 설정할 수 있습니다.

- **`PORT`**: 서버가 실행될 포트 번호. (기본값: `8080`)
- **`SHUTDOWN_TIMEOUT`**: 우아한 종료 시 대기 시간. (기본값: `5s`)
- **`ALLOWED_ORIGINS`**: WebSocket 연결을 허용할 Origin 목록 (쉼표로 구분). 설정하지 않으면 개발 편의를 위해 모든 Origin을 허용하며, 경고 메시지가 출력됩니다.
    - **프로덕션 예시:** `ALLOWED_ORIGINS="https://your-domain.com,https://www.your-domain.com"`
    - **ngrok 예시:** `ALLOWED_ORIGINS="https://your-ngrok-subdomain.ngrok.io"`
